# CodePrint

The intended purpose of this language is to provide a way to design and architect the scaffolding and structure of a piece of software, while providing clear direction for an LLM to fill in most of the implmentation pieces.

## Core Principles

* Structure First - The language should lean towards providing flexiblity towards structure of the resulting code. As a result it is designed to avoid going into the weeds unless necessary. Modularity and organization of high level concepts like Systems should be first class citizens.
* Simplicity  - The language is not intended to be heavily written by humans, and as a result, it should avoid the shortcuts and symbol optimization that many other high level languages use, in favor of a less complex language and one that is easier to read
* Control - It should be very easy for a human to perform their own implementation if they don't trust the AI (for example, critical business logic)

## Language Design

### Comments

Comments can be single line, with the `//` operator, or multiline with the `/* */` operators.

### Statements

A statement in CodePrint is any legal sequence of symbols that can be interpterted as executable by any interperter or transpiler. Following the principle of simplicity, statments should be as simple as they can be while still achieving the desired result. Breaking statements up into smaller statements and using intermediate variables is strongly encouraged.

Top level statements (statements that stand alone and are not part of other statements) must be terminated with a semicolon.

### Blocks

CodePrint supports the concept of blocks, code that is contained inside the `{` and closing `}`. This code may belong to a control statement such as a conditional or loop. Any variable created inside a block is scoped to that block and does not exist outside of it.

### Data Typing

CodePrint is strongly typed. This is primarily to reduce the confusion on an LLM when generating code. A better understanding of the inputs and outputs will serve to help the LLM make fewer mistakes. Strongly typed code is also easier to error check with static analysis, which helps to reduce bugs both by the LLM and the human coder.

### Standard Library

A mix between kitchen sink and minimalist. The standard library should contain enough Modules to permit 90% of common operations, but should not strive too hard to achieve further coverage.

### External Modules

To start off, CodePrint does not include a third party module system. This is because most of the methods you will need should be generated by LLM. Methods that would be difficult for the LLM to generate or require system access should be provided by the standard library.

## Language Basics

### Variables

Variables should be defined with the syntax `<modifier> <type> <name> = <statement>`, where the statement to provide the initial value is optional.

#### Modifiers

A few modifiers should be made available:

* `constant` - ensures the variable cannot be changed

#### Types

A variable can be of a complex type (such as an Object) or a basic type:

* `integer` - a whole number
* `number` - any valid number
* `string` - any series of valid unicode characters
* `boolean` - a true/false value
* `list<type>` - a list containing values of the given type
* `map<type>` - a map with keys being any valid basic type, and value being the given type

## Comparisons

A comparison is a statement takes in an operator, up to two statements, and produces a boolean value. Note that complex comparisons using parhenthesis are NOT SUPPORTED, to enforce simplicity of the code. If you have a need of this operation, it's recommended to use intermediate variables.

### Unary

There is a single unary operator, that being the `NOT`

* NOT - inverts the boolean output of the statement, `NOT <statement>`. Only works on a boolean

### Binary

There are a number of common binary operators that take in two statements.

* EQ/NE/LT/LTE/GT/GTE - standard comparisons for equality and comparison. `<statement> LT <statement>`. Can work on any basic type except lists and maps
* AND/OR - logical operations. Can only work on booleans.

## Conditionals

A conditional checks a comparison, and if the comparison evaluates to true, executes a corresponding code block. The standard `if`, `else if`, and `else` are supported.

```
if (myAge GT 65) {
    // some code that runs
} else if (myAge GTE 18) {

} else {

}
```

## Loops

A loop runs a specific block of code as long as the given condition is true. CodePrint provides three kinds of loops. These loops are relatively standard among most languages. Note the foreach works on both maps and lists.

```
while (<conditinal>) {
    // code to run while condition is true
}

for (<initial statement>;<conditional>;<accumulation statement>) {
    // code to run while condition is true
}

// key is optional
foreach (variable as key : value) {

}
```

## Functions

Functions are a block of code that can be invoked as desired by calling the function.

### Implementation

Functions are defined with the following statement: `function[<modifiers] <name>(<parameters>): <return type>`.

Functions are private by default

Functions have bodies just like loops or if statements. Parameters are valid for the function body scope.

```
function myFunc(Address address, integer cost): boolean {
    // some code
}
```

Note that generated code will have no body, ending with a semicolon.

#### Modifiers

A few modifiers should be made available:

* `public` - this function can be called outside of its containing Object or Module
* `generated` - the body of this function should be generated by LLM

### Calling Functions

Functions can be called by the following format: `<name>(<arguments>)`.

Arguments can be named or unnamed. Any unnamed arguments are assigned to function params in the order they are provided. Unnamed parameters cannot come after named parameters.

```
myFunc(someAddressVariable, cost=1000);
```